/*
0========(   VALERIE   )========0




0====( DEBUG TO DO )====0


Check exit_failure/exit_success dans les built-in. Look in execution of them

bash-Pew Pew> echo $bob
==4141== Invalid read of size 1
==4141==    at 0x100002C47: ft_strlen (ft_strlen.c:20)
==4141==    by 0x10000540C: expand (expander.c:35)
==4141==    by 0x100004C88: expand_token_list (tokenizer.c:143)
==4141==    by 0x100005701: parse_line (parser.c:25)
==4141==    by 0x1000037DB: minishell (main.c:33)
==4141==    by 0x100003924: main (main.c:48)
==4141==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
soit que je calloc pas assez; ou free quelque chose qu'on continue d'utiliser.


valgrind cmd:
valgrind --show-leak-kinds=all --trace-children=yes --leak-check=full --suppressions=supp.txt ./minishell


0====( TEST CASES )====0



0====( PROBS TO SOLVE )====0
1. /bin/ls : ne fonctionne pas
2. cat -e outfile2 ->fonctionne, mais imprime "cat: : No such file or directory" (argument -e non fonctionel?)
3. unset PATH --> juste après, si on fait ls, il trouve et exécute la cmd (normal?)
4. pwd segfault quand répété plusieurs fois
5. commande sans cmd_args dit que la cmd est invalide

6. weird empty strings


0========(   LOYC   )========0



0====( DEBUG TO DO )====0

handle argless cmds
handle unclosed "" and ''


0====( TEST CASES )====0

cmd
cmd arg1
cmd arg1 arg2

cmd >out1
cmd >>out1

cmd >out1 >out2
cmd >>out1 >>out3

cmd >out1 >>out2
cmd >>out1 >out2

<in1 cmd
<<in1 cmd

<in1 <in2 cmd
<<in1 <<in2

<<in1 <in2 cmd
<in1 <<in2 cmd

<in1 cmd arg1 >out1
<<in1 cmd arg1 >>out1

<in1 <in2 cmd arg1 arg2 >out1 >out2
<<in1 <<in2 cmd arg1 arg2 >>out1 >>out2

cmd1 | cmd2

<<in1 cmd1 | cmd2
cmd1 | <<in1 cmd2

*/
